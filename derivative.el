(require 'dash)

(cl-defstruct d/empty)
(cl-defstruct d/eps)
(cl-defstruct d/char value)
(cl-defstruct d/rep lang)
(cl-defstruct d/cat left right)
(cl-defstruct d/alt this that)

(defun nullable (L)
  (cl-typecase L
    (d/empty 'nil)
    (d/eps 't)
    (d/char 'nil)
    (d/rep 't)
    (d/alt (or (nullable (d/alt-this L))
	       (nullable (d/alt-that L))))
    (d/cat (and (nullable (d/cat-left L))
		(nullable (d/cat-right L))))))

(defun derivative (c L)
  (cl-typecase L
    (d/empty (make-d/empty))
    (d/eps (make-d/empty))
    (d/char (if (equal c (d/char-value L))
		(make-d/eps)
	      (make-d/empty)))
    (d/rep (make-d/cat :left (derivative c (d/rep-lang L))
		       :right L))
    (d/alt
     (let ((l1 (d/alt-this L))
	   (l2 (d/alt-that L)))
       (make-d/alt :this (derivative c l1)
		   :that (derivative c l2))))
    (d/cat
     (let ((l1 (d/cat-left L))
	   (l2 (d/cat-right L)))
       (if (not (nullable l1))
	   (make-d/cat :left (derivative c l1)
		       :right l2)
	 (make-d/alt :this (make-d/cat :left (derivative c l1)
				       :right l2)
		     :that (derivative c l2)))))))

(defun make-word-L (word)
  (if (not (equal word ""))
      (make-d/cat :left (make-d/char :value (substring word 0 1))
		  :right (make-word-L (substring word 1 (string-width word))))
    (make-d/eps)))

(defun check-word (word L)
  (if (equal word "")
      (nullable L)
    (let ((c (substring word 0 1))
	  (rest (substring word 1 (string-width word))))
      (check-word rest (derivative c L)))))

(check-word "hello" (make-word-L "hello"))

(--> (make-word-L "hell")
     (derivative "h" it)
     (derivative "e" it)
     ;; (derivative "l" it)
     ;; (derivative "l" it)
     ;; (derivative "o" it)
     )

(provide 'derivative)
